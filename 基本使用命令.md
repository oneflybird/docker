# docker的基本使用命令
>[ ]表示可选  
## 容器

1. 查看正在运行的容器  
` docker ps `  
查询最后一次创建的容器    
`docker ps -l`  
列出所有的容器 ID  
`docker ps -aq`

2. 在后台运行一个python的web应用  
`docker run -d -P [hostport]:[containerport] 镜像名 python 要运行的文件名如app.py`  
> 参数说明:  
-d:让容器在后台运行。  
-P:将容器内部使用的网络端口映射到我们使用的主机上   

    运行交互式容器  
`docker run -i -t 镜像名 /bin/bash`  
> 各个参数解析：  
-t:在新容器内指定一个伪终端或终端。  
-i:允许你对容器内的标准输入 (STDIN) 进行交互。    

    重新以交互模式进入存在的容器  
    `docker attach 容器id`  

3. 查看容器的端口映射  
`docker port 容器id` or `docker port 容器名`

4. 查看web应用程序日志  
`docker logs 容器ID或者名字`  
-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。

5. 停止容器  
`docker stop 容器名`  
停止所有的容器  
`docker stop $(docker ps -aq)`

6. 启动已经停止的web应用容器  
`docker start 容器id`  
重启没有停止的web应用容器  
`docker restart 容器id`  

7. 移除容器(移除容器时容器必须是停止状态)  
`docker rm 容器名`   
删除所有的容器  
`docker rm $(docker ps -aq)`   
删除所有停止的容器  
`docker container prune -f`

8. 退出容器  
`ctrl+d`

## 镜像
1.  载入镜像  
`docker pull 镜像名[：标签] `  
标签可选，没有标签默认latest

* 查看镜像  
`docker images`  

* 使用镜像  
`run 镜像名`

* 删除镜像  
`docker rmi 镜像名或id`  
删除所有的镜像  
`docker rmi $(docker images -q)`  
 删除所有不使用的镜像  
`docker image prune --force --all`

* 查找镜像  
`docker search 镜像名`

### 创建镜像
> 当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。  
1.从已经创建的容器中更新镜像，并且提交这个镜像  
2.使用 Dockerfile 指令来创建一个新的镜像

#### 从已经创建的容器中更新镜像
##### 更新镜像包
新镜像之前，我们需要使用镜像来创建一个容器。
runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash  
**root@e218edb10161:/# 在运行的容器内使用 `apt-get update` 命令进行更新和安装想要安装的包**
在完成操作之后，输入 `exit`命令来退出这个容器。

此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 `docker commit`来提交容器副本。

runoob@runoob:~$ `docker commit -m="has update" -a="runoob" e218edb10161 runoob/ubuntu:v2`
sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8
> 各个参数说明：  
-m: 提交的描述信息  
-a: 指定镜像作者  
e218edb10161：容器ID  
runoob/ubuntu:v2: 指定要创建的目标镜像名

我们可以使用 `docker images` 命令来查看我们的新镜像 runoob/ubuntu:v2：
##### 导入和导出镜像包
###### export和import
**export**  
`docker export 容器名 > 导出路径，一般以.tar结尾`  
举例：  
我们使用容器 furious_bell，现在要将这个容器保存为一个文件 myunbuntu-export-1204.tar  
`docker export furious_bell > /home/myubuntu-export-1204.tar`  
**import**  
`docker import - 要导入的包路径或url`  
举例：  
`docker import - /home/myubuntu-export-1204.tar`  
通过指定 URL 或者某个目录来导入  
`sudo docker import http://example.com/exampleimage.tgz example/imagerepo`
###### save和load  
**save**  
`docker save 9610cfc68e8d > /home/myubuntu-save-1204.tar`  
有点慢，稍微等待一下，没有任何warn信息就表示保存OK。9610cfc68e8d 是镜像ID   
**load**   
现在就可以在任何装 docker 的地方加载刚保存的镜像了   
`docker load < /home/myubuntu-save-1204.tar`
###### 导出 export 与 保存 save 的区别

1. export导出的镜像文件大小 小于 save保存的镜像

2. export 导出（import导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作（`docker tag <LAYER ID> <IMAGE NAME>`）；而save保存（load加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。（查看方式：`docker images --tree`） **确切的说，export其实是容器的保存，只把镜像当前的状态保存下来，没有历史版本等信息，所以文件比较小**

注：导入加载进来觉得不合适可以使用 docker rm 容器ID 、 docker rmi 镜像ID 来删掉和移除所有的容器和镜像（大扫除）：  
`docker kill $(docker ps -q)` ; `docker rm $(docker ps -a -q)` ; `docker rmi $(docker images -q -a)``   

---
#### 使用 Dockerfile 来创建一个新的镜像
##### 创建 Dockerfile文件
`vim dockerfile`   
##### 进入 dockerfile文件进行编辑    
> **Docker语法：**  
FROM 基础镜像base image
MAINTAINER 维护者   
RUN 执行命令  
ADD 添加文件  
COPY 拷贝文件  
CMD 执行命令  
EXPOSE 执行命令  
WORKDIR 指定路径    
ENV 设定环境变量
USER 指定路径  
VOLUME 逻辑卷挂载点mount point  
**注意事项**  
1. 使用apt-get install 要在最后加 --assume-yes ，否则会abort
2. 使用yum还是apt取决于base image环境，不是取决于自己服务器的环境
3. 每次使用RUN指令都是新增一层镜像，所以最好用&& 连接多个RUN
4. 换行是\
5. 为了让镜像包不臃肿最后要删除。。。什么什么的
###### 使用dockerfile  
`docker build -t 镜像名 dockfile所在目录，当前目录可用.`

---
## 参考
[菜鸟教程](http://www.runoob.com/docker)  
[停止、删除所有的docker容器和镜像](https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/)  
[docker从入门到实践](https://yeasy.gitbooks.io/docker_practice/introduction/what.html)
[导入和导出](https://blog.csdn.net/a906998248/article/details/46236687 )
